[
    {
        "uri": "/posts/ClangScanf的高级用法",
        "title": "ClangScanf的高级用法",
        "content": "\r\n# Scanf() 的高级用法\r\n\r\n## 指定读取长度\r\n\r\n还记得在 printf() 中可以指定最小输出宽度吗？就是在格式控制符的中间加上一个数字，例如，`%10d`\r\n\r\n- 如果整数的宽度不足 10，那么在左边以空格补齐；\r\n- 如果整数的宽度超过了 10，那么以整数本身的宽度来输出，",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang作用域",
        "title": "Clang作用域",
        "content": "\r\n全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（`.c`文件）和头文件（`.h`文件）。\r\n\r\n如果给全局变量加上 **static** 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。\r\n\r\n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang字符串",
        "title": "Clang字符串",
        "content": "\r\ngcc 好像不能成功编译utf-8编码格式的c语言文件。\r\n\r\n只要把c语言文件编码方式更改为ANSI即可。\r\n\r\nps:经实验：在windows下使用vscode的utf-8编码和Linux `",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang字符串处理函数",
        "title": "Clang字符串处理函数",
        "content": "\r\nC语言提供了丰富的字符串处理函数，可以对字符串进行输入、输出、合并、修改、比较、转换、复制、搜索等操作，使用这些现成的函数可以大大减轻我们的编程负担。\r\n\r\n用于输入输出的字符串函数，例如`printf`、`puts`、`scanf`、`gets`等，使用时要包含头文件`stdio.h`，而使用",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang字符串指针",
        "title": "Clang字符串指针",
        "content": "\r\n# 字符串指针\r\n\r\nC语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中\r\n\r\n```c\r\n#include \r\n#include \r\n\r\nint main(){\r\n    char str[] = \"http://c.biancheng.n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang宏定义",
        "title": "Clang宏定义",
        "content": "\r\n# #define的用法\r\n\r\n#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。\r\n\r\n```c\r\n#include \r\n#define N 100\r\ni",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang指针变量的运算",
        "title": "Clang指针变量的运算",
        "content": "\r\n# 指针变量的运算\r\n\r\n指针变量  保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，请看下面的代码：\r\n\r\n```c\r\n#include \r\n\r\nint main(){\r\n    int    a = 10,   *pa = &a,",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang指针是什么",
        "title": "Clang指针是什么",
        "content": "\r\n计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。\r\n\r\n下图是 4G 内存中每个字",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang数组1",
        "title": "Clang数组1",
        "content": "\r\n# 数组\r\n\r\n## 二维数组\r\n\r\n二维数组的初始化可以按行分段赋值，也可按行连续赋值。\r\n\r\n例如，对于数组 `a[5][3]`，按行分段赋值应该写作： \r\n\r\n```\r\nint a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang数组2",
        "title": "Clang数组2",
        "content": "\r\n# 数组是静态的，不能插入或删除元素\r\n\r\n在C语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为静态数组。\r\n\r\n反过来说，如果数组在定义后可以改变容量，允许在任意位置插入或者删除",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang数组灵活多变的访问形式",
        "title": "Clang数组灵活多变的访问形式",
        "content": "\r\nC语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”，请看下面的代码：\r\n\r\n```c\r\n#include \r\n\r\nint main()\r\n{\r\n    char str[20] = \"c.biancheng.net\";\r\n\r\n    char ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang条件编译",
        "title": "Clang条件编译",
        "content": "\r\n# C语言#if、##ifdef、#ifndef的用法详解，C语言条件编译详解\r\n\r\n假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux下都能运行，怎么办呢？\r\n\r\nWindows 有专有的宏`_WIN32`，Linux 有专有的宏`__linu",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang模拟密码输入显示星号",
        "title": "Clang模拟密码输入(显示星号)",
        "content": "\r\n一个安全的程序在用户输入密码时不应该显示密码本身，而应该回显星号或者点号，例如`······`或`******`，这在网页、PC软件、ATM机、POS机上经常看到。但是C语言没有提供类似的功能，控制台上只能原样显示用户输入的字符。\r\n\r\n```c\r\n#include \r\n#in",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang清空刷新缓冲区",
        "title": "Clang清空(刷新)缓冲区",
        "content": "\r\n缓冲区的优点很明显，它加快了程序的运行速度，减少了硬件的读写次数，让整个计算机变得流畅起来；但是，缓冲区也带来了一些负面影响\r\n\r\n那么，该如何消除这些负面影响呢？其实也很简单，在输入输出之前清空（刷新）缓冲区即可： \r\n\r\n- 对于输出操作，清空缓冲区会使得缓冲区中的所有数据立即显示到屏幕上；",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang缓冲区",
        "title": "Clang缓冲区",
        "content": "\r\n# 缓冲区\r\n\r\n缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang读取从键盘输入的数据",
        "title": "Clang读取从键盘输入的数据",
        "content": "\r\n在C语言中，有多个函数可以从键盘获得用户输入：\r\n\r\n-  scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。\r\n-  getchar()、getche()、getch()：这三个函数都用于输入单个字符。\r\n-  gets()：获取一行数据，并作为字符串处理。\r",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang输出汇总",
        "title": "Clang输出汇总",
        "content": "\n# 输出汇总\n\n`printf`格式控制符：\n\n| 格式控制符                       | 说明                                                         |\n| ------------------------------",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang递归函数",
        "title": "Clang递归函数",
        "content": "\r\n# 递归函数\r\n\r\n一个函数在它的函数体内调用它自身称为**递归调用**，这种函数称为**递归函数**。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。\r\n\r\n```c\r\n#include \r\n\r\nint factor",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang预处理命令",
        "title": "Clang预处理命令",
        "content": "\r\n在编译和链接之前，还需要对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，这个过程叫做预处理，由预处理程序完成。\r\n\r\n较之其他编程语言，C/C++ 语言更依赖预处理器，所以在阅读或开发 C/C++ 程序过程中，可能会接触大量的预处理指令，比如 #include、#defi",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/postsC语言学习",
        "title": "C语言学习",
        "content": "\n## 示例\n\n```c\n#include \t\t\t//包含标准输入输出头文件\n//standared input output header   标准输入输出头文件\nvoid main()\n{\n\tchar ch = 'a';\n\tprintf(\"ASCII码：%d\\n 字符: %c\\",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/postsC语言学习笔记常用函数",
        "title": "C语言学习笔记 常用函数",
        "content": "\n## Scanf函数\n\nC函数库包含了多个输入函数，scanf是最通用的一个，可以读取不同格式的数据\n\n### 基本用法\n\nVS中`scanf()`会被警告不安全，需要用`scanf_s`代替`scanf`\n\n```c\n#include \nvoid main()\n{\n\tint n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/postsC语言符号与进制",
        "title": "C语言符号与进制",
        "content": "\n# 内存\n\n  内存中存取数据要明确3件事：\n\n- 数据存储在哪里\n- 数据的长度\n- 数据的处理方式\n\n\n\n在32位环境中，各种数据类型的长度一般如下：\n\n| 说  明   | 字符型 | 短整型 | 整型 | 长整型 | 单精度浮点型 | 双精度浮点型 |\n| -------- | -----",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/C语言非阻塞式键盘监听用户不输入数据程序也能继续执行",
        "title": "C语言非阻塞式键盘监听(用户不输入数据程序也能继续执行)",
        "content": "\r\n所谓键盘监听，就是用户按下某个键时系统做出相应的处理，本章讲到的输入输出函数也是键盘监听函数的一种，例如 getchar()、getche()、getch() 等。下面的代码演示了 getche() 函数的使用：\r\n\r\n```c\r\n#include \r\n#include ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/GCC和GDB",
        "title": "GCC和GDB",
        "content": "\n# GCC\n\n GCC提供了大量的编译选项，大约有100个，其中最基本，最常用的参数如下：\n\n|选项|说明|\n-|-|-\n-o |\t使用指定的文件名保存编译后的二进制文件\n-O |\t对程序进行优化编译，链接；编译链接时的速度慢\n-O2 |\t提供比 -O 更好的优化编译；编译链接时比 -O 速度慢\n",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/IOT安全资料整合",
        "title": "IOT安全资料整合",
        "content": "\n# OT安全资料整合\n\n十一月 07, 2019\n\n- [build](/tags/build/)\n\n# [](#IOT-安全资料整合（主要是路由器） \"IOT 安全资料整合（主要是路由器）\")IOT 安全资料整合（主要是路由器）\n\n## [](#适合入门的资料 \"适合入门的资料\")适合入门的资料",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/MIPS32架构堆栈",
        "title": "MIPS32架构堆栈",
        "content": "\n# MIPS堆栈原理\n\n 在计算机科学中，栈是一种具有 先进后出(FILO) 队列特性的数据结构。调用栈(Call Stack) 是指存放某个程序正在运行的函数的信息的栈。调用栈由栈帧(Stack Fram",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/MIPS指令集",
        "title": "MIPS指令集",
        "content": "\n# MIPS汇编语言基础\n\nMIPS指令特点\n\n- MIPS 固定4字节指令长度\n- 内存中的数据访问 (load/store) 必须严格对齐（至少4字节对齐）\n- 跳转指令只有 26 位目标地址，加上 2 位对齐位，可寻址 28 位的空间，即 256MB\n- 条件分支指令只有 16 位跳转地址，",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/postsMIPS汇编语言基础",
        "title": "MIPS汇编语言基础",
        "content": "\n# 寄存器\n\n​      RISC的一个显著特点就是大量使用寄存器。因为寄存器的存取可以在一个时钟周期内完成，同时简化寻址方式，所以MIPS32的指令中除了加载/储存指令以外，都是用寄存器或者立即数作为操作数，以便让编译器通过保持对寄存器内数据的频繁存取进一步优化代码的生成性能。MIPS32中的",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/忽略语法细节从整体上理解函数",
        "title": "忽略语法细节,从整体上理解函数",
        "content": "\r\n从整体上看，C语言代码是由一个一个的函数构成的，除了定义和说明类的语句（例如变量定义、宏定义、类型定义等）可以放在函数外面，所有具有运算或逻辑处理能力的语句（例如加减乘除、[if else](http://c.biancheng.net/c/if_else/)、for、函数调用等）都要放在函数内",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/环境安装",
        "title": "环境安装",
        "content": "\n## 安装pwntools\n\n安装依赖\n\n```bash\ngit clone https://github.com/aquynh/capstone\ncd capstone\nmake\nmake install\n```\n\n安装pwntools(需要联网，简易使用国内源)\n\n```bash\nsudo a",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/结合Clang缓冲区谈scanf函数",
        "title": "结合Clang缓冲区谈scanf函数",
        "content": "\r\nscanf() 是从标准输入设备（键盘）读取数据，带有行缓冲区的，这让 scanf() \r\n具有了一些独特的“性格”，例如可以连续输入、可以输入多余的数据等。反过来，scanf() \r\n也出现了一些奇怪的行为，例如，有时候两份数据之间有空格会读取失败，而有时候两份数据之间又必须有空格。\r\n\r\ns",
        "tags": [
            "Clang"
        ]
    }
]