[
    {
        "uri": "/posts/ASCII码对照表",
        "title": "ASCII码对照表",
        "content": "\r\nASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是一套基于拉丁字母的字符编码，共收录了 128 个字符，用一个字节就可以存储，它等同于国际标准 ISO/IEC 646。\r\n\r\nASCII 规范于 1967 年",
        "tags": [
            "Clang",
            "对照表"
        ]
    },
    {
        "uri": "/posts/Clangconst的用法详解",
        "title": "Clang_const的用法详解",
        "content": "\r\n## const的用法\r\n\r\n有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用`const`关键字对变量加以限定：\r\n\r\n```c\r\nconst int MaxNum = 100; ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clangtypedef的用法详解",
        "title": "Clang_typedef的用法详解",
        "content": "\r\n## typedef\r\n\r\nC语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。\r\n\r\n起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是 stu，要想定义一个结构体变量就得这样写：\r\n\r\n```c\r\nstruct stu stu1;\r\n```\r\n\r\ns",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/ClangScanf的高级用法",
        "title": "ClangScanf的高级用法",
        "content": "\r\n# Scanf() 的高级用法\r\n\r\n## 指定读取长度\r\n\r\n还记得在 printf() 中可以指定最小输出宽度吗？就是在格式控制符的中间加上一个数字，例如，`%10d`\r\n\r\n- 如果整数的宽度不足 10，那么在左边以空格补齐；\r\n- 如果整数的宽度超过了 10，那么以整数本身的宽度来输出，",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang位域",
        "title": "Clang位域",
        "content": "\r\n有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的  数据结构。\r\n\r\n在结构体定义时，我们可以指定某个成员",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang位运算",
        "title": "Clang位运算",
        "content": "\r\n所谓**位运算**，就是对一个比特（Bit）位进行操作。比特（Bit）是一个电子元器件，8个比特构成一个字节（Byte），它已经是粒度最小的可操作单元了。\r\n\r\nC语言提供了六种位运算符：\r\n\r\n| 运算符 | &      | \\|     | ^        | ~    | ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang作用域",
        "title": "Clang作用域",
        "content": "\r\n全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（`.c`文件）和头文件（`.h`文件）。\r\n\r\n如果给全局变量加上 **static** 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。\r\n\r\n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang使用位运算对数据或文件内容进行加密",
        "title": "Clang使用位运算对数据或文件内容进行加密",
        "content": "\r\n数据加密解密是一个常用的功能，如果你不希望让别人看到文件中的内容，可以通过密钥（也称”密码“）将文件的内容加密。比如文本文件(.txt)，加密前的内容是能够读懂的，加密后的内容是”乱码“，都是一些奇怪的字符，根本无法阅读。\r\n\r\n数据加密解密的原理也很简单，就是使用异或运算。请先看下面的代码：\r",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang共用体",
        "title": "Clang共用体",
        "content": "\r\n# 共同体\r\n\r\n结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做**共用体（Union）**，它的定义格式为：\r\n\r\n```c\r\nunion 共用体名{\r\n    成员列表\r\n};\r\n```\r\n\r\n共用体有时也被",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang函数指针",
        "title": "Clang函数指针",
        "content": "\r\n一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。\r\n\r\n函数指针的定义形",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang字符串",
        "title": "Clang字符串",
        "content": "\r\ngcc 好像不能成功编译utf-8编码格式的c语言文件。\r\n\r\n只要把c语言文件编码方式更改为ANSI即可。\r\n\r\nps:经实验：在windows下使用vscode的utf-8编码和Linux `",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang字符串处理函数",
        "title": "Clang字符串处理函数",
        "content": "\r\nC语言提供了丰富的字符串处理函数，可以对字符串进行输入、输出、合并、修改、比较、转换、复制、搜索等操作，使用这些现成的函数可以大大减轻我们的编程负担。\r\n\r\n用于输入输出的字符串函数，例如`printf`、`puts`、`scanf`、`gets`等，使用时要包含头文件`stdio.h`，而使用",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang字符串指针",
        "title": "Clang字符串指针",
        "content": "\r\n# 字符串指针\r\n\r\nC语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中\r\n\r\n```c\r\n#include \r\n#include \r\n\r\nint main(){\r\n    char str[] = \"http://c.biancheng.n",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang宏定义",
        "title": "Clang宏定义",
        "content": "\r\n# #define的用法\r\n\r\n#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。\r\n\r\n```c\r\n#include \r\n#define N 100\r\ni",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang指针作为函数返回值",
        "title": "Clang指针作为函数返回值",
        "content": "\r\nC语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。下面的例子定义了一个函数 strlong()，用来返回两个字符串中较长的一个：\r\n\r\n```c\r\n用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang指针变量的运算",
        "title": "Clang指针变量的运算",
        "content": "\r\n# 指针变量的运算\r\n\r\n指针变量  保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，请看下面的代码：\r\n\r\n```c\r\n#include \r\n\r\nint main(){\r\n    int    a = 10,   *pa = &a,",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang指针数组",
        "title": "Clang指针数组",
        "content": "\r\n# 指针数组\r\n\r\n如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：\r\n\r\n```c\r\ndataType *arrayName[length];\r\n```\r\n\r\n`[ ]`的优先级高于`*`，该定义形式应该理解为：\r\n\r\n```c\r\ndataType ",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang指针是什么",
        "title": "Clang指针是什么",
        "content": "\r\n计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。\r\n\r\n下图是 4G 内存中每个字",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/Clang数组1",
        "title": "Clang数组1",
        "content": "\r\n# 数组\r\n\r\n## 二维数组\r\n\r\n二维数组的初始化可以按行分段赋值，也可按行连续赋值。\r\n\r\n例如，对于数组 `a[5][3]`，按行分段赋值应该写作： \r\n\r\n```\r\nint a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang数组2",
        "title": "Clang数组2",
        "content": "\r\n# 数组是静态的，不能插入或删除元素\r\n\r\n在C语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为静态数组。\r\n\r\n反过来说，如果数组在定义后可以改变容量，允许在任意位置插入或者删除",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang数组灵活多变的访问形式",
        "title": "Clang数组灵活多变的访问形式",
        "content": "\r\nC语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”，请看下面的代码：\r\n\r\n```c\r\n#include \r\n\r\nint main()\r\n{\r\n    char str[20] = \"c.biancheng.net\";\r\n\r\n    char ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang条件编译",
        "title": "Clang条件编译",
        "content": "\r\n# C语言#if、##ifdef、#ifndef的用法详解，C语言条件编译详解\r\n\r\n假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux下都能运行，怎么办呢？\r\n\r\nWindows 有专有的宏`_WIN32`，Linux 有专有的宏`__linu",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang枚举类型",
        "title": "Clang枚举类型",
        "content": "\r\n在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。\r\n\r\n以每周七天为例，我们可以使用`#define`命令来给每天指定一个名字：\r\n\r\n```c\r\n#includ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang模拟密码输入显示星号",
        "title": "Clang模拟密码输入(显示星号)",
        "content": "\r\n一个安全的程序在用户输入密码时不应该显示密码本身，而应该回显星号或者点号，例如`······`或`******`，这在网页、PC软件、ATM机、POS机上经常看到。但是C语言没有提供类似的功能，控制台上只能原样显示用户输入的字符。\r\n\r\n```c\r\n#include \r\n#in",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang清空刷新缓冲区",
        "title": "Clang清空(刷新)缓冲区",
        "content": "\r\n缓冲区的优点很明显，它加快了程序的运行速度，减少了硬件的读写次数，让整个计算机变得流畅起来；但是，缓冲区也带来了一些负面影响\r\n\r\n那么，该如何消除这些负面影响呢？其实也很简单，在输入输出之前清空（刷新）缓冲区即可： \r\n\r\n- 对于输出操作，清空缓冲区会使得缓冲区中的所有数据立即显示到屏幕上；",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang结构体",
        "title": "Clang结构体",
        "content": "\r\n# 结构体\r\n\r\n前面的教程中我们讲解了 数组（Array)，它是一组具有相同类型的数据的集合。但在实际的编程过程中，我们往往还需要一组类型不同的数据，例如对于学生信息登记表，姓名为字符串，学号为整数，年龄为整数，所在的学习小组为字符，成绩为小数，因为数据类型不同，显然不能用一个数组来存放。\r\n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang结构体指针",
        "title": "Clang结构体指针",
        "content": "\r\n# 结构体指针\r\n\r\n当一个指针**结构体指针**C语言结构体指针\r\n\r\n```c\r\n struct 结构体名 *变量名;\r\n```\r\n\r\n```c\r\n//结构体//结构体\r\nstruct stu{\r\n    char *name;  //姓名\r\n    int num;  //学号\r\n    ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang缓冲区",
        "title": "Clang缓冲区",
        "content": "\r\n# 缓冲区\r\n\r\n缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang读取从键盘输入的数据",
        "title": "Clang读取从键盘输入的数据",
        "content": "\r\n在C语言中，有多个函数可以从键盘获得用户输入：\r\n\r\n-  scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。\r\n-  getchar()、getche()、getch()：这三个函数都用于输入单个字符。\r\n-  gets()：获取一行数据，并作为字符串处理。\r",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang输出汇总",
        "title": "Clang输出汇总",
        "content": "\n# 输出汇总\n\n`printf`格式控制符：\n\n| 格式控制符                       | 说明                                                         |\n| ------------------------------",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang递归函数",
        "title": "Clang递归函数",
        "content": "\r\n# 递归函数\r\n\r\n一个函数在它的函数体内调用它自身称为**递归调用**，这种函数称为**递归函数**。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。\r\n\r\n```c\r\n#include \r\n\r\nint factor",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang针数组和二级指针",
        "title": "Clang针数组和二级指针",
        "content": "\r\n```c\r\n#include \r\n\r\nint main(){\r\n    char *lines[5] = {\r\n        \"COSC1283/1284\",\r\n        \"Programming\",\r\n        \"Techniques\",\r\n        \"i",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang随机数rand和srand用法详解",
        "title": "Clang随机数rand和srand用法详解",
        "content": "\r\n## 随机数\r\n\r\n在实际编程中，我们经常需要生成随机数，例如，贪吃蛇游戏中在随机的位置出现食物，扑克牌游戏中随机发牌。\r\n\r\n在C语言中，我们一般使用  头文件中的 rand() 函数来生成随机数，它的用法为：\r\n\r\n```c\r\nint rand (void);\r\n```\r",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/Clang预处理命令",
        "title": "Clang预处理命令",
        "content": "\r\n在编译和链接之前，还需要对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，这个过程叫做预处理，由预处理程序完成。\r\n\r\n较之其他编程语言，C/C++ 语言更依赖预处理器，所以在阅读或开发 C/C++ 程序过程中，可能会接触大量的预处理指令，比如 #include、#defi",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/C指针的总结",
        "title": "C指针的总结",
        "content": "\r\n指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。\r\n\r\n程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/postsC语言学习",
        "title": "C语言学习",
        "content": "\n## 示例\n\n```c\n#include \t\t\t//包含标准输入输出头文件\n//standared input output header   标准输入输出头文件\nvoid main()\n{\n\tchar ch = 'a';\n\tprintf(\"ASCII码：%d\\n 字符: %c\\",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/postsC语言学习笔记常用函数",
        "title": "C语言学习笔记 常用函数",
        "content": "\n## Scanf函数\n\nC函数库包含了多个输入函数，scanf是最通用的一个，可以读取不同格式的数据\n\n### 基本用法\n\nVS中`scanf()`会被警告不安全，需要用`scanf_s`代替`scanf`\n\n```c\n#include \nvoid main()\n{\n\tint n",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/postsC语言符号与进制",
        "title": "C语言符号与进制",
        "content": "\n# 内存\n\n  内存中存取数据要明确3件事：\n\n- 数据存储在哪里\n- 数据的长度\n- 数据的处理方式\n\n\n\n在32位环境中，各种数据类型的长度一般如下：\n\n| 说  明   | 字符型 | 短整型 | 整型 | 长整型 | 单精度浮点型 | 双精度浮点型 |\n| -------- | -----",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/C语言非阻塞式键盘监听用户不输入数据程序也能继续执行",
        "title": "C语言非阻塞式键盘监听(用户不输入数据程序也能继续执行)",
        "content": "\r\n所谓键盘监听，就是用户按下某个键时系统做出相应的处理，本章讲到的输入输出函数也是键盘监听函数的一种，例如 getchar()、getche()、getch() 等。下面的代码演示了 getche() 函数的使用：\r\n\r\n```c\r\n#include \r\n#include ",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/GCC和GDB",
        "title": "GCC和GDB",
        "content": "\n# GCC\n\n GCC提供了大量的编译选项，大约有100个，其中最基本，最常用的参数如下：\n\n|选项|说明|\n-|-|-\n-o |\t使用指定的文件名保存编译后的二进制文件\n-O |\t对程序进行优化编译，链接；编译链接时的速度慢\n-O2 |\t提供比 -O 更好的优化编译；编译链接时比 -O 速度慢\n",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/IOT安全资料整合",
        "title": "IOT安全资料整合",
        "content": "\n# OT安全资料整合\n\n十一月 07, 2019\n\n- [build](/tags/build/)\n\n# [](#IOT-安全资料整合（主要是路由器） \"IOT 安全资料整合（主要是路由器）\")IOT 安全资料整合（主要是路由器）\n\n## [](#适合入门的资料 \"适合入门的资料\")适合入门的资料",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/iptables转发",
        "title": "Iptables转发",
        "content": "\r\n# iptables 常用命令\r\n\r\n```bash\r\niptables -I INPUT -p tcp --dport 1234 -j ACCEPT\r\niptables -I INPUT -p udp --dport 1234 -j ACCEPT\r\niptables -t nat -nvL #",
        "tags": [
            "Linux"
        ]
    },
    {
        "uri": "/posts/main函数的高级用法接收用户输入的数据",
        "title": "Main()函数的高级用法 接收用户输入的数据",
        "content": "\r\nmain() 是C语言程序的入口函数，有且只能有一个，它实际上有两种标准的原型：\r\n\r\n```c\r\nint main();\r\nint main(int argc, char *argv[]);\r\n```\r\n\r\n前面的教程中我们一直使用第一种原型，它简单易懂，能让初学者很快入手。第二种原型在实际开",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/MIPS32架构堆栈",
        "title": "MIPS32架构堆栈",
        "content": "\n# MIPS堆栈原理\n\n 在计算机科学中，栈是一种具有 先进后出(FILO) 队列特性的数据结构。调用栈(Call Stack) 是指存放某个程序正在运行的函数的信息的栈。调用栈由栈帧(Stack Fram",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/MIPS指令集",
        "title": "MIPS指令集",
        "content": "\n# MIPS汇编语言基础\n\nMIPS指令特点\n\n- MIPS 固定4字节指令长度\n- 内存中的数据访问 (load/store) 必须严格对齐（至少4字节对齐）\n- 跳转指令只有 26 位目标地址，加上 2 位对齐位，可寻址 28 位的空间，即 256MB\n- 条件分支指令只有 16 位跳转地址，",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/postsMIPS汇编语言基础",
        "title": "MIPS汇编语言基础",
        "content": "\n# 寄存器\n\n​      RISC的一个显著特点就是大量使用寄存器。因为寄存器的存取可以在一个时钟周期内完成，同时简化寻址方式，所以MIPS32的指令中除了加载/储存指令以外，都是用寄存器或者立即数作为操作数，以便让编译器通过保持对寄存器内数据的频繁存取进一步优化代码的生成性能。MIPS32中的",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/只需一招彻底攻克C语言指针",
        "title": "只需一招,彻底攻克C语言指针",
        "content": "\r\n前面我们讲解了指针数组、二维数组指针、函数指针等几种较为复杂的指针，它们的定义形式分别是：\r\n\r\n```c\r\nint *p1[6];  //指针数组\r\nint *(p2[6]);  //指针数组，和上面的形式等价\r\nint (*p3)[6];  //二维数组指针\r\nint (*p4)(int, ",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/国内开源站点列表",
        "title": "国内开源站点列表",
        "content": "\r\n最后更新于：2018-09-13 \r\n\r\n一、站点版 \r\n （一）、企业站 \r\n 1.搜狐：http://mirrors.sohu.com/ \r\n 2.网易：http://mirrors.163.com/ \r\n 3.阿里云：http://mirrors.aliyun.com/ \r\n 4.腾讯：h",
        "tags": [
            "Clang",
            "其他资源"
        ]
    },
    {
        "uri": "/posts/大端小端以及判别方式",
        "title": "大端小端以及判别方式",
        "content": "\r\n大端和小端是指数据在内存中的存储模式，它由 CPU 决定：\r\n\r\n- 大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/忽略语法细节从整体上理解函数",
        "title": "忽略语法细节,从整体上理解函数",
        "content": "\r\n从整体上看，C语言代码是由一个一个的函数构成的，除了定义和说明类的语句（例如变量定义、宏定义、类型定义等）可以放在函数外面，所有具有运算或逻辑处理能力的语句（例如加减乘除、[if else](http://c.biancheng.net/c/if_else/)、for、函数调用等）都要放在函数内",
        "tags": [
            "Clang"
        ]
    },
    {
        "uri": "/posts/数组和指针绝不等价数组是另外一种类型",
        "title": "数组和指针绝不等价,数组是另外一种类型",
        "content": "\r\n通过前面的讲解，相信很多读者都会认为数组和指针是等价的，数组名表示数组的首地址。不幸的是，这是一种非常危险的想法，并不完全正确，前面我们将数组和指针等价起来是为了方便大家理解（在大多数情况下数组名确实可以当做指针使用），不至于被指针难倒，这节请大家放弃这种观念，我将会颠覆你的认知。\r\n\r\n数组和",
        "tags": [
            "Clang",
            "指针"
        ]
    },
    {
        "uri": "/posts/环境安装",
        "title": "环境安装",
        "content": "\n## 安装pwntools\n\n安装依赖\n\n```bash\ngit clone https://github.com/aquynh/capstone\ncd capstone\nmake\nmake install\n```\n\n安装pwntools(需要联网，简易使用国内源)\n\n```bash\nsudo a",
        "tags": [
            "MIPS"
        ]
    },
    {
        "uri": "/posts/结合Clang缓冲区谈scanf函数",
        "title": "结合Clang缓冲区谈scanf函数",
        "content": "\r\nscanf() 是从标准输入设备（键盘）读取数据，带有行缓冲区的，这让 scanf() \r\n具有了一些独特的“性格”，例如可以连续输入、可以输入多余的数据等。反过来，scanf() \r\n也出现了一些奇怪的行为，例如，有时候两份数据之间有空格会读取失败，而有时候两份数据之间又必须有空格。\r\n\r\ns",
        "tags": [
            "Clang"
        ]
    }
]