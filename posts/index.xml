<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Some Notes</title>
    <link>https://axcuan.github.io/posts/</link>
    <description>Recent content in Posts on Some Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 18 Jan 2020 16:03:55 +0800</lastBuildDate>
    
	<atom:link href="https://axcuan.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Socket函数</title>
      <link>https://axcuan.github.io/posts/socket%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 18 Jan 2020 16:03:55 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/socket%E5%87%BD%E6%95%B0/</guid>
      <description>socket函数 Linux下的socket函数 Linux 中的一切都是文件，每个文件都有一个整数类型的文件描述符；socket 也是一个文件，也有文件描述符。使用</description>
    </item>
    
    <item>
      <title>插入、删除、更改文件内容</title>
      <link>https://axcuan.github.io/posts/%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Thu, 09 Jan 2020 21:28:29 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>我们平时所见的文件，例如 txt、doc、mp4 等，文件内容是按照从头到尾的顺序依次存储在磁盘上的，就像排起一条长长的队伍，称为顺序文件。 除了顺序文件，</description>
    </item>
    
    <item>
      <title>获取文件大小(长度)</title>
      <link>https://axcuan.github.io/posts/%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Thu, 09 Jan 2020 21:26:01 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%95%BF%E5%BA%A6/</guid>
      <description>实际开发中，有时候需要先获取文件大小再进行下一步操作。C语言没有提供获取文件大小的函数，要想实现该功能，必须自己编写函数。 ftell()函数 ftell() 函数用来</description>
    </item>
    
    <item>
      <title>C语言FILE结构体以及缓冲区深入探讨</title>
      <link>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80FILE%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</link>
      <pubDate>Thu, 09 Jan 2020 21:21:49 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80FILE%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</guid>
      <description>在C语言中，用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。 定义文件指针的一般形式为： FILE *fp; 这里的FILE</description>
    </item>
    
    <item>
      <title>Clang实现文件复制功能(包括文本文件和二进制文件)</title>
      <link>https://axcuan.github.io/posts/Clang%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E5%8C%85%E6%8B%AC%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 21:18:31 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E5%8C%85%E6%8B%AC%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/</guid>
      <description>文件的复制是常用的功能，要求写一段代码，让用户输入要复制的文件以及新建的文件，然后对文件进行复制。能够复制的文件包括文本文件和二进制文件，你可以复制1</description>
    </item>
    
    <item>
      <title>Rewind和fseek函数的用法详解(随机读写文件)</title>
      <link>https://axcuan.github.io/posts/rewind%E5%92%8Cfseek%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 21:10:42 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/rewind%E5%92%8Cfseek%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>前面介绍的文件读写函数都是顺序读写，即读写文件只能从头开始，依次读写各个数据。但在实际开发中经常需要读写文件的中间部分，要解决这个问题，就得先移动文件</description>
    </item>
    
    <item>
      <title>Fscanf和fprintf函数的用法详解(格式化读写文件)</title>
      <link>https://axcuan.github.io/posts/fscanf%E5%92%8Cfprintf%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 21:02:30 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/fscanf%E5%92%8Cfprintf%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>fscanf() 和 fprintf() 函数与前面使用的 scanf() 和 printf() 功能相似，都是格式化读写函数，两者的区别在于 fscanf() 和 fprintf() 的读写对象不是键盘和显示器，而是磁盘文件。 这两个函数的原型为： int fscanf ( FILE *fp,</description>
    </item>
    
    <item>
      <title>Fread和fwrite的用法详解(以数据块的形式读写文件)</title>
      <link>https://axcuan.github.io/posts/fread%E5%92%8Cfwrite%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 20:52:24 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/fread%E5%92%8Cfwrite%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>fgets() 有局限性，每次最多只能从文件中读取一行内容，因为 fgets() 遇到换行符就结束读取。如果希望读取多行内容，需要使用 fread() 函数；相应地写入函数为 fwrite()。 对于</description>
    </item>
    
    <item>
      <title>Fgets和fputs函数的用法详解(以字符串的形式读写文件)</title>
      <link>https://axcuan.github.io/posts/fgets%E5%92%8Cfputs%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 20:45:28 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/fgets%E5%92%8Cfputs%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>fgetc() 和 fputc() 函数每次只能读写一个字符，速度较慢；实际开发中往往是每次读写一个字符串或者一个数据块，这样能明显提高效率。 读字符串函数 fgets fgets() 函数用来从指定的文件中</description>
    </item>
    
    <item>
      <title>Fgetc和fputc函数用法(以字符形式读写文件)</title>
      <link>https://axcuan.github.io/posts/fgetc%E5%92%8Cfputc%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Jan 2020 20:26:41 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/fgetc%E5%92%8Cfputc%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>在C语言中，读写文件比较灵活，既可以每次读写一个字符，也可以读写一个字符串，甚至是任意字节的数据（数据块）。 以字符形式读写文件时，每次可以从文件中读取</description>
    </item>
    
    <item>
      <title>文本文件和二进制文件到底有什么区别</title>
      <link>https://axcuan.github.io/posts/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 09 Jan 2020 20:21:46 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>fopen() 函数，我们知道它的第二个参数是一个字符串，用来表示文件打开方式。如果字符串中出现b，则表示以二进制方式打开文件；如果字符串中出现t，或者两者都不出现</description>
    </item>
    
    <item>
      <title>Clang文件操作</title>
      <link>https://axcuan.github.io/posts/Clang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 09 Jan 2020 20:00:14 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。例如： 通常把显示器</description>
    </item>
    
    <item>
      <title>国内开源站点列表</title>
      <link>https://axcuan.github.io/posts/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Wed, 08 Jan 2020 23:26:02 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E7%AB%99%E7%82%B9%E5%88%97%E8%A1%A8/</guid>
      <description>最后更新于：2018-09-13 一、站点版 （一）、企业站 1.搜狐：http://mirrors.sohu.com/ 2.网易：http://mirror</description>
    </item>
    
    <item>
      <title>ASCII码对照表</title>
      <link>https://axcuan.github.io/posts/ASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</link>
      <pubDate>Wed, 08 Jan 2020 23:17:45 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/ASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</guid>
      <description>ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是一套基于拉丁字母的字符编码，共收录了 128 个字符，用一个字节就可以存储</description>
    </item>
    
    <item>
      <title>Clang随机数rand和srand用法详解</title>
      <link>https://axcuan.github.io/posts/Clang%E9%9A%8F%E6%9C%BA%E6%95%B0rand%E5%92%8Csrand%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 08 Jan 2020 23:02:39 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E9%9A%8F%E6%9C%BA%E6%95%B0rand%E5%92%8Csrand%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>随机数 在实际编程中，我们经常需要生成随机数，例如，贪吃蛇游戏中在随机的位置出现食物，扑克牌游戏中随机发牌。 在C语言中，我们一般使用 头文件中的 rand() 函数来生</description>
    </item>
    
    <item>
      <title>Clang_const的用法详解</title>
      <link>https://axcuan.github.io/posts/Clang_const%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 08 Jan 2020 22:56:06 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang_const%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>const的用法 有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小</description>
    </item>
    
    <item>
      <title>Clang_typedef的用法详解</title>
      <link>https://axcuan.github.io/posts/Clang_typedef%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 08 Jan 2020 22:47:04 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang_typedef%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>typedef C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。 起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是 st</description>
    </item>
    
    <item>
      <title>Clang使用位运算对数据或文件内容进行加密</title>
      <link>https://axcuan.github.io/posts/Clang%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%88%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Wed, 08 Jan 2020 22:43:49 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%88%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/</guid>
      <description>数据加密解密是一个常用的功能，如果你不希望让别人看到文件中的内容，可以通过密钥（也称”密码“）将文件的内容加密。比如文本文件(.txt)，加密前的内容</description>
    </item>
    
    <item>
      <title>Clang位运算</title>
      <link>https://axcuan.github.io/posts/Clang%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Wed, 08 Jan 2020 22:30:51 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>所谓位运算，就是对一个比特（Bit）位进行操作。比特（Bit）是一个电子元器件，8个比特构成一个字节（Byte），它已经是粒度最小的可操作单元了。 C语</description>
    </item>
    
    <item>
      <title>Clang位域</title>
      <link>https://axcuan.github.io/posts/Clang%E4%BD%8D%E5%9F%9F/</link>
      <pubDate>Wed, 08 Jan 2020 22:17:55 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E4%BD%8D%E5%9F%9F/</guid>
      <description>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正</description>
    </item>
    
    <item>
      <title>大端小端以及判别方式</title>
      <link>https://axcuan.github.io/posts/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%88%A4%E5%88%AB%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 08 Jan 2020 22:06:50 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%88%A4%E5%88%AB%E6%96%B9%E5%BC%8F/</guid>
      <description>大端和小端是指数据在内存中的存储模式，它由 CPU 决定： 大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的</description>
    </item>
    
    <item>
      <title>Clang共用体</title>
      <link>https://axcuan.github.io/posts/Clang%E5%85%B1%E7%94%A8%E4%BD%93/</link>
      <pubDate>Wed, 08 Jan 2020 21:40:08 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%85%B1%E7%94%A8%E4%BD%93/</guid>
      <description>共同体 结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Uni</description>
    </item>
    
    <item>
      <title>Clang枚举类型</title>
      <link>https://axcuan.github.io/posts/Clang%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 06 Jan 2020 20:38:11 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</guid>
      <description>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十</description>
    </item>
    
    <item>
      <title>Clang结构体指针</title>
      <link>https://axcuan.github.io/posts/Clang%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 05 Jan 2020 20:19:34 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/</guid>
      <description>结构体指针 当一个指针结构体指针C语言结构体指针 struct 结构体名 *变量名; //结构体//结构体 struct stu{ char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //</description>
    </item>
    
    <item>
      <title>Clang结构体</title>
      <link>https://axcuan.github.io/posts/Clang%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Sun, 05 Jan 2020 19:13:34 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>结构体 前面的教程中我们讲解了 数组（Array)，它是一组具有相同类型的数据的集合。但在实际的编程过程中，我们往往还需要一组类型不同的数据，例如对于学生</description>
    </item>
    
    <item>
      <title>C指针的总结</title>
      <link>https://axcuan.github.io/posts/C%E6%8C%87%E9%92%88%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 05 Jan 2020 19:08:02 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E6%8C%87%E9%92%88%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以</description>
    </item>
    
    <item>
      <title>Main()函数的高级用法 接收用户输入的数据</title>
      <link>https://axcuan.github.io/posts/main%E5%87%BD%E6%95%B0%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sun, 05 Jan 2020 18:14:10 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/main%E5%87%BD%E6%95%B0%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>main() 是C语言程序的入口函数，有且只能有一个，它实际上有两种标准的原型： int main(); int main(int argc, char *argv[]); 前面的教程中我们一直使用第一种原型，它简单易懂，能让初学者很快入手。</description>
    </item>
    
    <item>
      <title>只需一招,彻底攻克C语言指针</title>
      <link>https://axcuan.github.io/posts/%E5%8F%AA%E9%9C%80%E4%B8%80%E6%8B%9B%E5%BD%BB%E5%BA%95%E6%94%BB%E5%85%8BC%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 05 Jan 2020 17:19:28 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E5%8F%AA%E9%9C%80%E4%B8%80%E6%8B%9B%E5%BD%BB%E5%BA%95%E6%94%BB%E5%85%8BC%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
      <description>前面我们讲解了指针数组、二维数组指针、函数指针等几种较为复杂的指针，它们的定义形式分别是： int *p1[6]; //指针数组 int *(p2[6]); //指针数组，和上面的形式等价 int (*p3)[6]; //二</description>
    </item>
    
    <item>
      <title>Clang函数指针</title>
      <link>https://axcuan.github.io/posts/Clang%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 05 Jan 2020 17:12:43 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</guid>
      <description>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入</description>
    </item>
    
    <item>
      <title>Clang针数组和二级指针</title>
      <link>https://axcuan.github.io/posts/Clang%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 05 Jan 2020 15:44:07 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; int main(){ char *lines[5] = { &amp;quot;COSC1283/1284&amp;quot;, &amp;quot;Programming&amp;quot;, &amp;quot;Techniques&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;great fun&amp;quot; }; char *str1 = lines[1]; char *str2 = *(lines + 3); char c1 = *(*(lines + 4) + 6); char c2 = (*lines + 5)[5]; char c3 = *lines[0] + 2; printf(&amp;quot;str1 = %s\n&amp;quot;, str1); printf(&amp;quot;str2 = %s\n&amp;quot;, str2); printf(&amp;quot; c1 = %c\n&amp;quot;, c1); printf(&amp;quot; c2 = %c\n&amp;quot;, c2); printf(&amp;quot; c3 = %c\n&amp;quot;, c3); return 0; } 为了方便</description>
    </item>
    
    <item>
      <title>Clang指针数组</title>
      <link>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 05 Jan 2020 15:38:18 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</guid>
      <description>指针数组 如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为： dataType *arrayName[length]; [ ]的优先级高于*，该定义形式应该理解为： dataType *(arrayName[length]);</description>
    </item>
    
    <item>
      <title>数组和指针绝不等价,数组是另外一种类型</title>
      <link>https://axcuan.github.io/posts/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%9D%E4%B8%8D%E7%AD%89%E4%BB%B7%E6%95%B0%E7%BB%84%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 05 Jan 2020 15:08:57 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%9D%E4%B8%8D%E7%AD%89%E4%BB%B7%E6%95%B0%E7%BB%84%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%9E%8B/</guid>
      <description>通过前面的讲解，相信很多读者都会认为数组和指针是等价的，数组名表示数组的首地址。不幸的是，这是一种非常危险的想法，并不完全正确，前面我们将数组和指针等</description>
    </item>
    
    <item>
      <title>Clang指针作为函数返回值</title>
      <link>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Sun, 05 Jan 2020 14:31:13 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>C语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。下面的例子定义了一个函数 strlong()，用来返回两个字符串中较长的一个： 用</description>
    </item>
    
    <item>
      <title>Iptables转发</title>
      <link>https://axcuan.github.io/posts/iptables%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Sun, 05 Jan 2020 12:49:58 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/iptables%E8%BD%AC%E5%8F%91/</guid>
      <description>iptables 常用命令 iptables -I INPUT -p tcp --dport 1234 -j ACCEPT iptables -I INPUT -p udp --dport 1234 -j ACCEPT iptables -t nat -nvL #查看nat链 iptables -t nat -N MY_TCP #在nat表上新建名为MY_TCP自定义链 iptables -t nat -A PREROUTING -j MY_TCP #将MY_TCP</description>
    </item>
    
    <item>
      <title>Clang数组灵活多变的访问形式</title>
      <link>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%84%E7%81%B5%E6%B4%BB%E5%A4%9A%E5%8F%98%E7%9A%84%E8%AE%BF%E9%97%AE%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 04 Jan 2020 23:10:12 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%84%E7%81%B5%E6%B4%BB%E5%A4%9A%E5%8F%98%E7%9A%84%E8%AE%BF%E9%97%AE%E5%BD%A2%E5%BC%8F/</guid>
      <description>C语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”，请看下面的代码： #include &amp;lt;stdio.h&amp;gt; int main() { char str[20] = &amp;quot;c.biancheng.net&amp;quot;; char *s1 = str; char *s2 = str + 2; char c1 = str[4]; char</description>
    </item>
    
    <item>
      <title>Clang字符串指针</title>
      <link>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 04 Jan 2020 23:02:48 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88/</guid>
      <description>字符串指针 C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main(){ char str[] = &amp;quot;http://c.biancheng.net&amp;quot;; int len = strlen(str), i; //直接输出字符串 printf(&amp;quot;%s\n&amp;quot;, str); //每次输出一个字符 for(i=0;</description>
    </item>
    
    <item>
      <title>Clang指针变量的运算</title>
      <link>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sat, 04 Jan 2020 20:33:25 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97/</guid>
      <description>指针变量的运算 指针变量 保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，请看下面的代码： #include &amp;lt;stdio.h&amp;gt; int main(){ int a = 10, *pa =</description>
    </item>
    
    <item>
      <title>Clang指针是什么</title>
      <link>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 04 Jan 2020 19:36:58 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节</description>
    </item>
    
    <item>
      <title>Clang条件编译</title>
      <link>https://axcuan.github.io/posts/Clang%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sat, 04 Jan 2020 18:31:54 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</guid>
      <description>C语言#if、##ifdef、#ifndef的用法详解，C语言条件编译详解 假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Li</description>
    </item>
    
    <item>
      <title>Clang宏定义</title>
      <link>https://axcuan.github.io/posts/Clang%E5%AE%8F%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Sat, 04 Jan 2020 18:10:33 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid>
      <description>#define的用法 #define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那</description>
    </item>
    
    <item>
      <title>Clang预处理命令</title>
      <link>https://axcuan.github.io/posts/Clang%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 04 Jan 2020 17:49:38 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</guid>
      <description>在编译和链接之前，还需要对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，这个过程叫做预处理，由预处理程序完成。 较之其他编程语言</description>
    </item>
    
    <item>
      <title>忽略语法细节,从整体上理解函数</title>
      <link>https://axcuan.github.io/posts/%E5%BF%BD%E7%95%A5%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E4%BB%8E%E6%95%B4%E4%BD%93%E4%B8%8A%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 04 Jan 2020 17:43:45 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E5%BF%BD%E7%95%A5%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E4%BB%8E%E6%95%B4%E4%BD%93%E4%B8%8A%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0/</guid>
      <description>从整体上看，C语言代码是由一个一个的函数构成的，除了定义和说明类的语句（例如变量定义、宏定义、类型定义等）可以放在函数外面，所有具有运算或逻辑处理能力</description>
    </item>
    
    <item>
      <title>Clang递归函数</title>
      <link>https://axcuan.github.io/posts/Clang%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 04 Jan 2020 17:03:22 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</guid>
      <description>递归函数 一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行</description>
    </item>
    
    <item>
      <title>Clang作用域</title>
      <link>https://axcuan.github.io/posts/Clang%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Sat, 04 Jan 2020 16:49:55 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（.c文件）和头文件（.h文件）。 如果给全局变量加上 static 关键字，它的作用域就变成了当前文</description>
    </item>
    
    <item>
      <title>Clang数组2</title>
      <link>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%842/</link>
      <pubDate>Wed, 01 Jan 2020 20:13:27 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%842/</guid>
      <description>数组是静态的，不能插入或删除元素 在C语言中，数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置</description>
    </item>
    
    <item>
      <title>Clang字符串处理函数</title>
      <link>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 01 Jan 2020 19:39:32 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</guid>
      <description>C语言提供了丰富的字符串处理函数，可以对字符串进行输入、输出、合并、修改、比较、转换、复制、搜索等操作，使用这些现成的函数可以大大减轻我们的编程负担。</description>
    </item>
    
    <item>
      <title>Clang数组1</title>
      <link>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%841/</link>
      <pubDate>Wed, 01 Jan 2020 18:25:36 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%95%B0%E7%BB%841/</guid>
      <description>数组 二维数组 二维数组的初始化可以按行分段赋值，也可按行连续赋值。 例如，对于数组 a[5][3]，按行分段赋值应该写作： int a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} }; 按行连续赋值应该写</description>
    </item>
    
    <item>
      <title>C语言非阻塞式键盘监听(用户不输入数据程序也能继续执行)</title>
      <link>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC%E7%94%A8%E6%88%B7%E4%B8%8D%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E7%A8%8B%E5%BA%8F%E4%B9%9F%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Wed, 01 Jan 2020 16:38:03 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC%E7%94%A8%E6%88%B7%E4%B8%8D%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E7%A8%8B%E5%BA%8F%E4%B9%9F%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</guid>
      <description>所谓键盘监听，就是用户按下某个键时系统做出相应的处理，本章讲到的输入输出函数也是键盘监听函数的一种，例如 getchar()、getche()、getc</description>
    </item>
    
    <item>
      <title>Clang模拟密码输入(显示星号)</title>
      <link>https://axcuan.github.io/posts/Clang%E6%A8%A1%E6%8B%9F%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%98%BE%E7%A4%BA%E6%98%9F%E5%8F%B7/</link>
      <pubDate>Wed, 01 Jan 2020 16:17:38 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%A8%A1%E6%8B%9F%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%98%BE%E7%A4%BA%E6%98%9F%E5%8F%B7/</guid>
      <description>一个安全的程序在用户输入密码时不应该显示密码本身，而应该回显星号或者点号，例如······或******，这在网页、PC软件、ATM机、POS机上经常</description>
    </item>
    
    <item>
      <title>ClangScanf的高级用法</title>
      <link>https://axcuan.github.io/posts/ClangScanf%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 01 Jan 2020 15:48:53 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/ClangScanf%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid>
      <description>Scanf() 的高级用法 指定读取长度 还记得在 printf() 中可以指定最小输出宽度吗？就是在格式控制符的中间加上一个数字，例如，%10d 如果整数的宽度不足 10，那么在左边以空格</description>
    </item>
    
    <item>
      <title>结合Clang缓冲区谈scanf函数</title>
      <link>https://axcuan.github.io/posts/%E7%BB%93%E5%90%88Clang%E7%BC%93%E5%86%B2%E5%8C%BA%E8%B0%88scanf%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 01 Jan 2020 15:20:07 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E7%BB%93%E5%90%88Clang%E7%BC%93%E5%86%B2%E5%8C%BA%E8%B0%88scanf%E5%87%BD%E6%95%B0/</guid>
      <description>scanf() 是从标准输入设备（键盘）读取数据，带有行缓冲区的，这让 scanf() 具有了一些独特的“性格”，例如可以连续输入、可以输入多余的数据等。反过来，scanf() 也出</description>
    </item>
    
    <item>
      <title>Clang清空(刷新)缓冲区</title>
      <link>https://axcuan.github.io/posts/Clang%E6%B8%85%E7%A9%BA%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA/</link>
      <pubDate>Wed, 01 Jan 2020 13:17:02 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E6%B8%85%E7%A9%BA%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA/</guid>
      <description>缓冲区的优点很明显，它加快了程序的运行速度，减少了硬件的读写次数，让整个计算机变得流畅起来；但是，缓冲区也带来了一些负面影响 那么，该如何消除这些负面影</description>
    </item>
    
    <item>
      <title>Clang缓冲区</title>
      <link>https://axcuan.github.io/posts/Clang%E7%BC%93%E5%86%B2%E5%8C%BA/</link>
      <pubDate>Wed, 01 Jan 2020 12:59:13 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E7%BC%93%E5%86%B2%E5%8C%BA/</guid>
      <description>缓冲区 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，</description>
    </item>
    
    <item>
      <title>Clang读取从键盘输入的数据</title>
      <link>https://axcuan.github.io/posts/Clang%E8%AF%BB%E5%8F%96%E4%BB%8E%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 31 Dec 2019 23:13:08 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E8%AF%BB%E5%8F%96%E4%BB%8E%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>在C语言中，有多个函数可以从键盘获得用户输入： scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。 getchar()、getche()、g</description>
    </item>
    
    <item>
      <title>Clang字符串</title>
      <link>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 31 Dec 2019 00:02:47 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>gcc 好像不能成功编译utf-8编码格式的c语言文件。 只要把c语言文件编码方式更改为ANSI即可。 ps:经实验：在windows下使用vscode的utf</description>
    </item>
    
    <item>
      <title>Clang输出汇总</title>
      <link>https://axcuan.github.io/posts/Clang%E8%BE%93%E5%87%BA%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sun, 29 Dec 2019 19:29:04 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/Clang%E8%BE%93%E5%87%BA%E6%B1%87%E6%80%BB/</guid>
      <description>输出汇总 printf格式控制符： 格式控制符 说明 %c 输出一个单一的字符 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数</description>
    </item>
    
    <item>
      <title>C语言符号与进制</title>
      <link>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E7%AC%A6%E5%8F%B7%E4%B8%8E%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Thu, 26 Dec 2019 23:47:21 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E7%AC%A6%E5%8F%B7%E4%B8%8E%E8%BF%9B%E5%88%B6/</guid>
      <description>内存 内存中存取数据要明确3件事： 数据存储在哪里 数据的长度 数据的处理方式 在32位环境中，各种数据类型的长度一般如下： 说 明 字符型 短整型 整型 长整型 单精度浮点</description>
    </item>
    
    <item>
      <title>C语言学习</title>
      <link>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 15 Dec 2019 13:23:09 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</guid>
      <description>示例 #include &amp;lt;stdio.h&amp;gt; //包含标准输入输出头文件 //standared input output header 标准输入输出头文件 void main() { char ch = &#39;a&#39;; printf(&amp;quot;ASCII码：%d\n 字符: %c\n 大小写之分只有一个空</description>
    </item>
    
    <item>
      <title>C语言学习笔记 常用函数</title>
      <link>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 15 Dec 2019 13:22:53 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>Scanf函数 C函数库包含了多个输入函数，scanf是最通用的一个，可以读取不同格式的数据 基本用法 VS中scanf()会被警告不安全，需要用scanf</description>
    </item>
    
    <item>
      <title>GCC和GDB</title>
      <link>https://axcuan.github.io/posts/GCC%E5%92%8CGDB/</link>
      <pubDate>Sun, 15 Dec 2019 13:22:14 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/GCC%E5%92%8CGDB/</guid>
      <description>GCC GCC提供了大量的编译选项，大约有100个，其中最基本，最常用的参数如下： |选项|说明| -|-|- -o | 使用指定的文件名保存编译后的二进制文件 -O | 对程序进行优</description>
    </item>
    
    <item>
      <title>环境安装</title>
      <link>https://axcuan.github.io/posts/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 15 Dec 2019 13:21:50 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</guid>
      <description>安装pwntools 安装依赖 git clone https://github.com/aquynh/capstone cd capstone make make install 安装pwntools(需要联网，简易使用国内源) sudo apt-get install python-dev libffi-dev openssl-devel -y git clone https://github.com/Gallopsled/pwntools cd pwntools sudo python setup.py install 安装gdb输入插件 git clone https://github.com/Ovi3/pstdio.git ~/pstdio</description>
    </item>
    
    <item>
      <title>IOT安全资料整合</title>
      <link>https://axcuan.github.io/posts/IOT%E5%AE%89%E5%85%A8%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/</link>
      <pubDate>Sun, 15 Dec 2019 13:21:18 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/IOT%E5%AE%89%E5%85%A8%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/</guid>
      <description>OT安全资料整合 十一月 07, 2019 build [](#IOT-安全资料整合（主要是路由器） &amp;ldquo;IOT 安全资料整合（主要是路由器）&amp;rdquo;)IOT 安全资料整合（主要是路由器</description>
    </item>
    
    <item>
      <title>MIPS32架构堆栈</title>
      <link>https://axcuan.github.io/posts/MIPS32%E6%9E%B6%E6%9E%84%E5%A0%86%E6%A0%88/</link>
      <pubDate>Sun, 15 Dec 2019 13:20:51 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/MIPS32%E6%9E%B6%E6%9E%84%E5%A0%86%E6%A0%88/</guid>
      <description>MIPS堆栈原理 在计算机科学中，栈是一种具有 先进后出(FILO) 队列特性的数据结构。调用栈(Call Stack) 是指存放某个程序正在运行的函数的信息的栈。调用栈</description>
    </item>
    
    <item>
      <title>MIPS指令集</title>
      <link>https://axcuan.github.io/posts/MIPS%E6%8C%87%E4%BB%A4%E9%9B%86/</link>
      <pubDate>Sun, 15 Dec 2019 13:20:02 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/MIPS%E6%8C%87%E4%BB%A4%E9%9B%86/</guid>
      <description>MIPS汇编语言基础 MIPS指令特点 MIPS 固定4字节指令长度 内存中的数据访问 (load/store) 必须严格对齐（至少4字节对齐） 跳转指令只有 26 位目标地址，加上 2 位对齐位，可寻</description>
    </item>
    
    <item>
      <title>MIPS汇编语言基础</title>
      <link>https://axcuan.github.io/posts/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 Dec 2019 22:23:23 +0800</pubDate>
      
      <guid>https://axcuan.github.io/posts/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</guid>
      <description>寄存器 ​ RISC的一个显著特点就是大量使用寄存器。因为寄存器的存取可以在一个时钟周期内完成，同时简化寻址方式，所以MIPS32的指令中除了加载/储存指</description>
    </item>
    
  </channel>
</rss>